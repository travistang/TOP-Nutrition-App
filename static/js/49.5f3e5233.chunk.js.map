{"version":3,"file":"static/js/49.5f3e5233.chunk.js","mappings":"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","sources":["domain/GPX/index.ts","domain/GPX/colors.ts","components/GPXPathViewer/GPXDetailViewModal/GPXMapLine.tsx","components/GPXPathViewer/GPXDetailViewModal/GPXMapUserLocationPin.tsx","components/GPXPathViewer/GPXDetailViewModal/GPXMapView.tsx","components/GPXPathViewer/GPXDetailViewModal/GPXElevationChart/useElevationChartOption.ts","components/GPXPathViewer/GPXDetailViewModal/GPXElevationChart/index.tsx","components/GPXPathViewer/GPXDetailViewModal/GPXStatistics.tsx","components/GPXPathViewer/GPXDetailViewModal/index.tsx","components/GPXPathViewer/index.tsx","components/Input/GPXInput/index.tsx","components/CreateCardioExerciseRecordModal/GPXFilePicker.tsx"],"sourcesContent":["import { XMLParser } from \"fast-xml-parser\";\nimport NumberUtils from \"../../utils/Number\";\nimport ArrayUtils from \"../../utils/Array\";\n\nexport type RawGPXTrackPoint = {\n  \"@_lat\": number;\n  \"@_lon\": number;\n  ele?: number;\n};\n\nexport type RawGPXFile = {\n  gpx: {\n    trk: {\n      name: string;\n      trkseg: {\n        trkpt: RawGPXTrackPoint[];\n      };\n    };\n  };\n};\n\nexport type GPXPoint = {\n  lat: number;\n  lon: number;\n  elevation: number | null;\n};\n\nexport type GPX = {\n  name: string;\n  points: GPXPoint[];\n};\nexport type GPXStatistics = {\n  minElevation: number | null;\n  maxElevation: number | null;\n  lengthKm: number;\n  elevationGain: number;\n  elevationLoss: number;\n};\n\nexport type GPXViewport = {\n  center: [number, number];\n  bounds: [[number, number], [number, number]];\n};\n\nexport const gpxToPath = (rawGpx: RawGPXFile): GPX => {\n  return {\n    name: rawGpx.gpx.trk.name,\n    points: rawGpx.gpx.trk.trkseg.trkpt.map((point) => ({\n      lat: parseFloat(point[\"@_lat\"].toString()),\n      lon: parseFloat(point[\"@_lon\"].toString()),\n      elevation: point.ele ?? null,\n    })),\n  };\n};\n\nconst distance = (from: GPXPoint, to: GPXPoint) => {\n  const { lat: lat1, lon: lon1 } = from;\n  const { lat: lat2, lon: lon2 } = to;\n\n  // https://stackoverflow.com/a/21623206\n  const p = 0.017453292519943295; // Math.PI / 180\n  const c = Math.cos;\n  const a =\n    0.5 -\n    c((lat2 - lat1) * p) / 2 +\n    (c(lat1 * p) * c(lat2 * p) * (1 - c((lon2 - lon1) * p))) / 2;\n\n  return 12742 * Math.asin(Math.sqrt(a)); // 2 * R; R = 6371 km\n};\n\nexport const slope = (from: GPXPoint, to: GPXPoint) => {\n  const dist = Math.abs(distance(from, to));\n  if (to.elevation === null || from.elevation === null) return null;\n  const elevationDiffKm = (to.elevation - from.elevation) / 1000;\n  return Math.atan(elevationDiffKm / dist);\n};\n\nexport const parseGPXFile = async (blob: Blob) => {\n  const text = await blob.text();\n  const parser = new XMLParser({\n    ignoreAttributes: false,\n  });\n  const content = parser.parse(text, true) as RawGPXFile;\n  if (!content?.gpx?.trk?.trkseg?.trkpt?.length) {\n    throw new Error(\"Invalid or empty GPX file\");\n  }\n\n  return gpxToPath(content);\n};\n\nexport const DEFAULT_GPX_STATISTICS: GPXStatistics = {\n  minElevation: null,\n  maxElevation: null,\n  lengthKm: 0,\n  elevationGain: 0,\n  elevationLoss: 0,\n};\n\nexport const computeGpxStatistics = (gpx: GPX): GPXStatistics => {\n  const statistics: GPXStatistics = { ...DEFAULT_GPX_STATISTICS };\n\n  gpx.points.forEach((point, i, points) => {\n    const currentElevation = point.elevation;\n    const nextPoint = points[i + 1];\n    if (currentElevation !== null) {\n      if (\n        statistics.minElevation === null ||\n        currentElevation < statistics.minElevation\n      ) {\n        statistics.minElevation = currentElevation;\n      }\n\n      if (\n        statistics.maxElevation === null ||\n        currentElevation > statistics.maxElevation\n      ) {\n        statistics.maxElevation = currentElevation;\n      }\n\n      const nextPointElevation = nextPoint?.elevation;\n      if (!Number.isFinite(nextPointElevation)) return;\n      const elevationDifference = nextPointElevation! - currentElevation;\n      if (elevationDifference < 0) {\n        statistics.elevationLoss -= elevationDifference;\n      } else {\n        statistics.elevationGain += elevationDifference;\n      }\n    }\n\n    if (nextPoint) {\n      statistics.lengthKm += distance(point, nextPoint);\n    }\n  });\n  return statistics;\n};\n\nexport const computeGpxViewport = (gpx: GPX): GPXViewport => {\n  const { points } = gpx;\n  if (points.length <= 1) {\n    throw new Error(\"Insufficient points for computing GPX Viewport\");\n  }\n\n  const xs = points.map((p) => p.lat);\n  const ys = points.map((p) => p.lon);\n\n  const centerX = NumberUtils.average(...xs);\n  const centerY = NumberUtils.average(...ys);\n\n  const minX = NumberUtils.min(...xs);\n  const maxX = NumberUtils.max(...xs);\n  const minY = NumberUtils.min(...ys);\n  const maxY = NumberUtils.max(...ys);\n  return {\n    center: [centerX, centerY],\n    bounds: [\n      [minX, minY],\n      [maxX, maxY],\n    ],\n  };\n};\n\nexport const computeAccumulativeDistance = (gpx: GPX): number[] => {\n  if (gpx.points.length === 0) return [];\n\n  const accumulatedDistances = [0];\n  let totalDistance = 0;\n  for (const i in gpx.points) {\n    const point = gpx.points[i];\n    const nextPoint = gpx.points[+i + 1];\n    if (!nextPoint) break;\n    totalDistance += distance(point, nextPoint);\n    accumulatedDistances.push(totalDistance);\n  }\n  return accumulatedDistances;\n}\n\nexport const computeSVGPathForGPX = (gpx: GPX) => {\n  if (gpx.points.length <= 1) return \"\";\n  const normalizedRange = { min: 0, max: 100 };\n  const [xs, ys] = [\n    NumberUtils.normalize(normalizedRange, ...gpx.points.map((p) => p.lat)),\n    NumberUtils.normalize(normalizedRange, ...gpx.points.map((p) => p.lon)),\n  ];\n\n  const int = (n: number) => Math.round(n);\n  const command = (cmd: \"M\" | \"L\", point: [number, number]) =>\n    ` ${cmd} ${int(point[0])} ${int(point[1])}`;\n\n  let path = command(\"M\", [xs[0], ys[0]]);\n\n  ArrayUtils.zip(xs, ys)\n    .slice(1)\n    .forEach((point, i) => {\n      path += command(\"L\", point);\n    });\n\n  return path;\n};\n","import { GPXPoint, slope } from \".\";\nimport NumberUtils from \"../../utils/Number\";\n\ntype RGB = [number, number, number];\n\nconst SLOPE_COLOR_CONFIG = {\n  min: {\n    value: NumberUtils.degToRad(-70),\n    color: [0, 255, 0],\n  },\n  max: {\n    value: NumberUtils.degToRad(50),\n    color: [255, 0, 0],\n  },\n};\nexport const getColorBySegment = (from: GPXPoint, to: GPXPoint): RGB => {\n  const segmentSlope = slope(from, to);\n  if (segmentSlope === null) {\n    return [0, 0, 0];\n  }\n  const ratio = NumberUtils.ratioIn(\n    SLOPE_COLOR_CONFIG.min.value,\n    segmentSlope,\n    SLOPE_COLOR_CONFIG.max.value\n  );\n  const clippedRatio = NumberUtils.clip(0, ratio, 1);\n  const colorInterpolated = NumberUtils.interpolateVector(\n    SLOPE_COLOR_CONFIG.min.color,\n    SLOPE_COLOR_CONFIG.max.color,\n    clippedRatio\n  ) as RGB;\n  return colorInterpolated;\n};\n\nexport const rgbVecToString = (rgb: RGB): string => {\n  return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;\n};\n","import React, { useMemo } from \"react\";\nimport { LatLng } from \"leaflet\";\nimport { Polyline, useMapEvent } from \"react-leaflet\";\nimport { GPX, GPXPoint } from \"../../../domain/GPX\";\nimport { getColorBySegment, rgbVecToString } from \"../../../domain/GPX/colors\";\n\ntype Props = {\n  gpx: GPX;\n  onInspectPointIndex: (index: number) => void;\n};\n\nconst getClosestPointTo = (latlng: LatLng, positions: GPXPoint[], thresholdMeter = 50) => {\n  let minDist = Infinity;\n  let index = -1;\n  for (let i = 0; i < positions.length; i++) {\n    const position = positions[i];\n    const dist = latlng.distanceTo([position.lat, position.lon]);\n    if (dist < minDist) {\n      index = i;\n      minDist = dist;\n    }\n  }\n  if (minDist > thresholdMeter) return null;\n  return index;\n}\nexport default function GPXMapLine({ gpx, onInspectPointIndex }: Props) {\n  const positions = useMemo(() => gpx.points, [gpx]);\n  useMapEvent('click', (event) => {\n    const clickedAt = event.latlng;\n    const closestPositionIndex = getClosestPointTo(clickedAt, positions);\n    if (closestPositionIndex !== null) {\n      onInspectPointIndex(closestPositionIndex);\n    }\n  });\n\n  return (\n    <>\n      {positions.map((position, i) =>\n        i === positions.length - 1 ? null : (\n          <Polyline\n            key={`${i}-${position.lat}-${position.lon}-${position.lat}-${position.lon}`}\n            color={rgbVecToString(\n              getColorBySegment(position, positions[i + 1])\n            )}\n            positions={[\n              [position.lat, position.lon],\n              [positions[i + 1].lat, positions[i + 1].lon],\n            ]}\n          />\n        )\n      )}\n    </>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport { toast } from \"react-hot-toast\";\nimport { Circle, Polyline } from \"react-leaflet\";\nimport NumberUtils from \"../../../utils/Number\";\n\nconst LINE_HEADING_LENGTH = 10;\nconst LINE_HEADING_HALF_ANGLE = 30;\ntype Coordinates = [number, number];\n\nconst computeLineHeadingCoordinates = (\n  position: GeolocationPosition\n): [[Coordinates, Coordinates], [Coordinates, Coordinates]] | null => {\n  const { heading, latitude, longitude } = position.coords;\n  if (heading === null) return null;\n  const leftLineHeading = NumberUtils.degToRad(\n    NumberUtils.normalizeDegree(heading - LINE_HEADING_HALF_ANGLE)\n  );\n  const rightLineHeading = NumberUtils.degToRad(\n    NumberUtils.normalizeDegree(heading + LINE_HEADING_HALF_ANGLE)\n  );\n  const leftLineLat =\n    latitude + LINE_HEADING_LENGTH * Math.sin(leftLineHeading);\n  const leftLineLng =\n    longitude + LINE_HEADING_LENGTH * Math.cos(leftLineHeading);\n\n  const rightLineLat =\n    latitude + LINE_HEADING_LENGTH * Math.sin(rightLineHeading);\n  const rightLineLng =\n    longitude + LINE_HEADING_LENGTH * Math.cos(rightLineHeading);\n\n  return [\n    [\n      [latitude, longitude],\n      [leftLineLat, leftLineLng],\n    ],\n    [\n      [latitude, longitude],\n      [rightLineLat, rightLineLng],\n    ],\n  ];\n};\n\nexport default function GPXMapUserLocationPin() {\n  const [userLocation, setUserLocation] = useState<GeolocationPosition | null>(\n    null\n  );\n\n  useEffect(() => {\n    const locationWatcher = window.navigator.geolocation.watchPosition(\n      setUserLocation,\n      () => toast.error(\"Unable to get your location\")\n    );\n    return () => window.navigator.geolocation.clearWatch(locationWatcher);\n  }, []);\n  if (!userLocation) return null;\n\n  const inverseAccuracyRatio = (100 - userLocation.coords.accuracy) / 100;\n  const [circleRadius] = NumberUtils.interpolateVector(\n    [40],\n    [500],\n    inverseAccuracyRatio\n  );\n\n  const lineHeadingCoords = computeLineHeadingCoordinates(userLocation);\n  return (\n    <>\n      {lineHeadingCoords && (\n        <>\n          <Polyline positions={lineHeadingCoords[0]} color=\"blue\" />\n          <Polyline positions={lineHeadingCoords[1]} color=\"blue\" />\n        </>\n      )}\n      <Circle\n        center={[userLocation.coords.latitude, userLocation.coords.longitude]}\n        radius={circleRadius}\n      />\n    </>\n  );\n}\n","import React from \"react\";\nimport { Circle, MapContainer, TileLayer } from \"react-leaflet\";\n\nimport { GPX, computeGpxViewport } from \"../../../domain/GPX\";\nimport GPXMapLine from \"./GPXMapLine\";\nimport GPXMapUserLocationPin from \"./GPXMapUserLocationPin\";\n\ntype Props = {\n  className?: string;\n  gpx: GPX;\n  inspectingPointIndex: number;\n  onInspectPointIndex: (index: number) => void;\n\n};\nexport default function GPXMapView({\n  className,\n  gpx,\n  inspectingPointIndex,\n  onInspectPointIndex,\n}: Props) {\n  const viewport = computeGpxViewport(gpx);\n  const inspectingPoint = gpx.points[inspectingPointIndex ?? -1] ?? null;\n  return (\n    <MapContainer\n      zoomControl={false}\n      center={viewport.center}\n      zoom={12}\n      className={className}\n      style={{ height: \"35vh\" }}\n    >\n      <TileLayer\n        attribution='&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n        url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n      />\n      <GPXMapLine\n        gpx={gpx}\n        onInspectPointIndex={onInspectPointIndex}\n      />\n      <GPXMapUserLocationPin />\n      {inspectingPoint && (\n        <Circle\n          center={[inspectingPoint.lat, inspectingPoint.lon]}\n          pathOptions={{ color: 'orange', fillColor: 'orange' }}\n          radius={60}\n        />\n      )}\n    </MapContainer>\n  );\n}\n","import { useMemo } from 'react';\nimport NumberUtils from '../../../../utils/Number';\n\nconst BASE_OPTION = {\n  responsive: true,\n  animation: { duration: 0 },\n   plugins: {\n    tooltip: { enabled: false }, legend: { display: false },\n    annotation: {\n      annotations: {} as Record<string, any>\n    }\n  },\n};\ntype CreateAnnotationsOption = {\n  index: number;\n  color: string;\n  yMax: number;\n  yMin: number;\n  name: string;\n  yValues: number[];\n}\nconst createAnnotationsAtIndex = ({\n  yValues,\n  index,\n  color,\n  yMax,\n  yMin,\n  name,\n}: CreateAnnotationsOption) => ({\n  [`${name}-line-horizontal`]: {\n    type: \"line\",\n    borderColor: color,\n    borderWidth: 2,\n    xMax: yValues.length - 1,\n    xMin: 0,\n    xScaleID: \"x\",\n    yMax: yValues[index],\n    yMin: yValues[index],\n    yScaleID: \"y\",\n  },\n  [`${name}-line`]: {\n    type: \"line\",\n    borderColor: color,\n    borderWidth: 2,\n    xMax: index,\n    xMin: index,\n    xScaleID: \"x\",\n    yMax,\n    yMin,\n    yScaleID: \"y\",\n  },\n  [`${name}-point`]: {\n    type: \"point\",\n    backgroundColor: color,\n    radius: 3,\n    borderWidth: 0,\n    xValue: index,\n    xScaleID: \"x\",\n    yValue: yValues[index],\n    yScaleID: \"y\",\n  }\n});\n\ntype UseElevationChartOptionProps = {\n  inspectPointIndex: number;\n  elevations: (number | null)[];\n}\nconst Y_AXIS_MARGIN = 100;\nexport default function useElevationChartOption({\n  elevations,\n  inspectPointIndex,\n}: UseElevationChartOptionProps) {\n  const yMax = useMemo(() => NumberUtils.max(...elevations) + Y_AXIS_MARGIN, [elevations]);\n  const yMin = useMemo(() => NumberUtils.min(...elevations) - Y_AXIS_MARGIN, [elevations]);\n  const finalOption = {\n    ...BASE_OPTION,\n    scales: {\n      y: {\n        min: yMin,\n        max: yMax,\n      },\n    },\n  };\n\n  if (inspectPointIndex >= 0) {\n    finalOption.plugins.annotation.annotations = {\n      ...finalOption.plugins.annotation.annotations,\n      ...createAnnotationsAtIndex({\n        index: inspectPointIndex,\n        yValues: elevations as number[],\n        yMax,\n        yMin,\n        name: \"inspect\",\n        color: \"orange\",\n      }),\n    };\n  }\n  return finalOption;\n}","import React, { useMemo, useRef } from \"react\";\nimport { Chart as ChartJS } from \"chart.js\";\nimport { Chart, getElementAtEvent } from \"react-chartjs-2\";\nimport { GPX, computeAccumulativeDistance } from \"../../../../domain/GPX\";\nimport { MarcoNutritionColor } from \"../../../../types/Nutrition\";\nimport useElevationChartOption from \"./useElevationChartOption\";\n\ntype Props = {\n  gpx: GPX;\n  inspectPointAtIndex: number;\n  onInspectPointAtIndex: (index: number) => void;\n};\nexport default function GPXElevationChart({\n  gpx,\n  inspectPointAtIndex,\n  onInspectPointAtIndex,\n}: Props) {\n  const chartRef = useRef<ChartJS>(null!);\n  const elevations = useMemo(() => gpx.points.map((p) => p.elevation), [gpx]);\n  const accumulatedDistances = useMemo(\n    () =>\n      computeAccumulativeDistance(gpx).map(\n        (cumsum) => `${cumsum.toFixed(1)} km`\n      ),\n    [gpx]\n  );\n  const options = useElevationChartOption({\n    elevations,\n    inspectPointIndex: inspectPointAtIndex,\n  });\n  if (elevations.length === 0) return null;\n  const lineData = {\n    labels: accumulatedDistances,\n    datasets: [\n      {\n        label: \"Elevation\",\n        data: elevations,\n        pointRadius: 1,\n        lineTension: 0.8,\n        borderColor: MarcoNutritionColor.fat,\n      }\n    ]\n  };\n\n  const onChartClick = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const chart = chartRef.current;\n    if (!chart) return;\n    const element = getElementAtEvent(chart, e);\n    if (element[0]?.index !== undefined) {\n      onInspectPointAtIndex(element[0]?.index ?? -1);\n    }\n  };\n\n  return (\n    <Chart\n      ref={chartRef}\n      type=\"line\"\n      onClick={onChartClick}\n      height={96}\n      data={lineData}\n      options={options}\n    />\n  );\n}\n","import React from 'react';\nimport classNames from 'classnames';\nimport { GPX, computeGpxStatistics } from '../../../domain/GPX';\nimport ScalarWidget from '../../Widgets/ScalarWidget';\n\ntype Props = {\n  gpx: GPX;\n  className?: string;\n}\nexport default function GPXStatistics({ className, gpx}: Props) {\n  const statistics = computeGpxStatistics(gpx);\n  return (\n    <div className={classNames(\"grid grid-cols-2 gap-2\", className)}>\n      <ScalarWidget label=\"Distance\" value={statistics.lengthKm} unit=\"km\" />\n      <ScalarWidget label=\"Highest point\" value={statistics.maxElevation} unit=\"hm\" />\n      <ScalarWidget label=\"Elevation Gain\" value={statistics.elevationGain} unit=\"hm\" className=\"col-start-1\" />\n      <ScalarWidget label=\"Elevation Loss\" value={statistics.elevationLoss} unit=\"hm\" />\n    </div>\n  )\n}","import React, { useState } from \"react\";\nimport Modal from \"../../Modal\";\nimport { GPX } from \"../../../domain/GPX\";\nimport GPXMapView from \"./GPXMapView\";\nimport GPXElevationChart from \"./GPXElevationChart\";\nimport GPXStatistics from \"./GPXStatistics\";\n\ntype Props = {\n  opened: boolean;\n  onClose: () => void;\n  gpx: GPX;\n};\nexport default function GPXDetailViewModal({\n  opened,\n  onClose,\n  gpx,\n}: Props) {\n  const [inspectingPointIndex, setInspectingPointIndex] = useState<number>(-1);\n  return (\n    <Modal opened={opened} onClose={onClose} label=\"GPX Details\">\n      <GPXMapView\n        inspectingPointIndex={inspectingPointIndex}\n        onInspectPointIndex={setInspectingPointIndex}\n        gpx={gpx}\n        className=\"rounded-lg w-full\"\n      />\n      <GPXElevationChart\n        inspectPointAtIndex={inspectingPointIndex}\n        onInspectPointAtIndex={setInspectingPointIndex}\n        gpx={gpx}\n      />\n      <GPXStatistics gpx={gpx} className=\"w-full\" />\n    </Modal>\n  );\n}\n","import React, { useMemo, useState } from \"react\";\nimport { GPX, computeSVGPathForGPX } from \"../../domain/GPX\";\nimport GPXDetailViewModal from \"./GPXDetailViewModal\";\n\ntype Props = {\n  gpx: GPX;\n  className?: string;\n};\n\nexport default function GPXPathViewer({ gpx, className }: Props) {\n  const [zoomed, setZoomed] = useState(false);\n  const svgPath = useMemo(() => {\n    return computeSVGPathForGPX(gpx);\n  }, [gpx]);\n\n  const toggleZoom = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    setZoomed(!zoomed);\n  };\n  return (\n    <>\n      <div onClick={(e) => e.stopPropagation()}>\n        <GPXDetailViewModal\n          gpx={gpx}\n          opened={zoomed}\n          onClose={() => setZoomed(false)}\n        />\n      </div>\n      <div onClick={toggleZoom} className=\"relative\">\n        <svg\n          viewBox=\"-10 -10 120 120\"\n          width=\"100%\"\n          height=\"100%\"\n          className={className}\n          style={{ transform: \"rotate(-80deg)\" }}\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <path\n            fill=\"none\"\n            style={{ strokeLinejoin: \"round\" }}\n            stroke=\"black\"\n            strokeWidth={1}\n            d={svgPath}\n          />\n        </svg>\n      </div>\n    </>\n  );\n}\n","import React, { ChangeEventHandler, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { GPX } from \"../../../domain/GPX\";\nimport GPXPathViewer from \"../../GPXPathViewer\";\nimport Button, { ButtonStyle } from \"../Button\";\n\ntype Props = {\n  gpx?: GPX;\n  onSelectGpx: (file?: Blob) => void;\n  className?: string;\n};\nexport default function GPXInput({ gpx, className, onSelectGpx }: Props) {\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const chooseFile = () => {\n    inputRef.current?.click();\n  };\n\n  const onFileChosen: ChangeEventHandler<HTMLInputElement> = async (e) => {\n    const fileSelected = e.target.files?.[0];\n    if (!fileSelected) return;\n    onSelectGpx(fileSelected);\n  };\n\n  const onClear = () => onSelectGpx(undefined);\n\n  return (\n    <div\n      onClick={chooseFile}\n      className={classNames(\n        \"relative cursor-pointer rounded-lg p-2 flex items-center bg-gray-300 gap-2\",\n        className\n      )}\n    >\n      <input\n        className=\"hidden\"\n        type=\"file\"\n        ref={inputRef}\n        accept=\".gpx\"\n        onInput={onFileChosen}\n      />\n      <div className=\"rounded-lg w-16 h-16 flex items-center justify-center\">\n        {gpx ? (\n          <GPXPathViewer gpx={gpx} />\n        ) : (\n          <FontAwesomeIcon icon=\"map\" className=\"child:fill-gray-100 w-4 h-4\" />\n        )}\n      </div>\n      {!!gpx && (\n        <div className=\"absolute -right-2 -bottom-2\" onClick={e => e.stopPropagation()}>\n          <Button className=\"w-4 h-4\" icon=\"trash\" textClassName=\"w-2 h-2\" buttonStyle={ButtonStyle.BlockDanger} onClick={onClear} />\n        </div>\n      )}\n    </div>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport { CardioExercise, CardioExerciseType } from \"../../types/CardioExercise\";\nimport GPXInput from \"../Input/GPXInput\";\nimport { GPX, parseGPXFile } from \"../../domain/GPX\";\nimport toast from \"react-hot-toast\";\n\nconst EXERCISE_WITH_GPX_FIELDS: CardioExerciseType[] = [\n  CardioExerciseType.Hiking,\n  CardioExerciseType.Running,\n];\ntype CardioExerciseWithGpx = Extract<CardioExercise, { gpx?: Blob }>;\ntype Props = {\n  record: CardioExercise;\n  className?: string;\n  onChange: (record: CardioExercise) => void;\n};\n\nexport default function GPXFilePicker({ record, className, onChange }: Props) {\n  const [gpx, setGpx] = useState<GPX | null>(null);\n  const hasGpxFieldInRecord = EXERCISE_WITH_GPX_FIELDS.includes(record.type);\n\n  useEffect(() => {\n    const gpxFile = (record as CardioExerciseWithGpx).gpx;\n    if (!gpxFile) {\n      setGpx(null);\n      return;\n    }\n    parseGPXFile(gpxFile)\n      .then(setGpx)\n      .catch(() => {\n        toast.error(\"Failed to parse GPX File\");\n      });\n  }, [record]);\n\n  if (!hasGpxFieldInRecord) return null;\n\n  const onSelectGpx = (gpx?: Blob) => {\n    onChange({ ...record, gpx } as CardioExerciseWithGpx);\n  };\n\n  return (\n    <GPXInput\n      gpx={gpx ?? undefined}\n      className={className}\n      onSelectGpx={onSelectGpx}\n    />\n  );\n}\n"],"names":["distance","from","to","lat","lat1","lon","lon1","lat2","lon2","p","c","Math","cos","a","asin","sqrt","parseGPXFile","async","_content$gpx","_content$gpx$trk","_content$gpx$trk$trks","_content$gpx$trk$trks2","text","blob","content","XMLParser","ignoreAttributes","parse","gpx","trk","trkseg","trkpt","length","Error","name","rawGpx","points","map","point","_point$ele","parseFloat","toString","elevation","ele","DEFAULT_GPX_STATISTICS","minElevation","maxElevation","lengthKm","elevationGain","elevationLoss","computeGpxStatistics","statistics","forEach","i","currentElevation","nextPoint","nextPointElevation","Number","isFinite","elevationDifference","computeGpxViewport","xs","ys","centerX","NumberUtils","average","centerY","minX","min","maxX","max","center","bounds","computeAccumulativeDistance","accumulatedDistances","totalDistance","push","computeSVGPathForGPX","normalizedRange","normalize","int","n","round","command","cmd","path","ArrayUtils","zip","slice","SLOPE_COLOR_CONFIG","value","degToRad","color","getColorBySegment","segmentSlope","slope","dist","abs","elevationDiffKm","atan","ratio","ratioIn","clippedRatio","clip","interpolateVector","rgbVecToString","rgb","getClosestPointTo","latlng","positions","thresholdMeter","arguments","undefined","minDist","Infinity","index","position","distanceTo","GPXMapLine","_ref","onInspectPointIndex","useMemo","useMapEvent","event","clickedAt","closestPositionIndex","_jsx","_Fragment","children","Polyline","computeLineHeadingCoordinates","heading","latitude","longitude","coords","leftLineHeading","normalizeDegree","rightLineHeading","sin","GPXMapUserLocationPin","userLocation","setUserLocation","useState","useEffect","locationWatcher","window","navigator","geolocation","watchPosition","toast","error","clearWatch","inverseAccuracyRatio","accuracy","circleRadius","lineHeadingCoords","_jsxs","Circle","radius","GPXMapView","_gpx$points","className","inspectingPointIndex","viewport","inspectingPoint","MapContainer","zoomControl","zoom","style","height","TileLayer","attribution","url","pathOptions","fillColor","BASE_OPTION","responsive","animation","duration","plugins","tooltip","enabled","legend","display","annotation","annotations","createAnnotationsAtIndex","yValues","yMax","yMin","type","borderColor","borderWidth","xMax","xMin","xScaleID","yScaleID","backgroundColor","xValue","yValue","Y_AXIS_MARGIN","GPXElevationChart","inspectPointAtIndex","onInspectPointAtIndex","chartRef","useRef","elevations","cumsum","toFixed","options","_ref2","inspectPointIndex","finalOption","scales","y","useElevationChartOption","lineData","labels","datasets","label","data","pointRadius","lineTension","MarcoNutritionColor","fat","Chart","ref","onClick","e","_element$","chart","current","element","getElementAtEvent","_element$0$index","_element$2","GPXStatistics","classNames","ScalarWidget","unit","GPXDetailViewModal","opened","onClose","setInspectingPointIndex","Modal","GPXPathViewer","zoomed","setZoomed","svgPath","stopPropagation","viewBox","width","transform","xmlns","fill","strokeLinejoin","stroke","strokeWidth","d","GPXInput","onSelectGpx","inputRef","chooseFile","_inputRef$current","click","accept","onInput","_e$target$files","fileSelected","target","files","FontAwesomeIcon","icon","Button","textClassName","buttonStyle","ButtonStyle","BlockDanger","onClear","EXERCISE_WITH_GPX_FIELDS","CardioExerciseType","Hiking","Running","GPXFilePicker","record","onChange","setGpx","hasGpxFieldInRecord","includes","gpxFile","then","catch"],"sourceRoot":""}